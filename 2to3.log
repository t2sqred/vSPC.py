$ 2to3 vSPC.py -w -n
RefactoringTool: Skipping optional fixer: buffer
RefactoringTool: Skipping optional fixer: idioms
RefactoringTool: Skipping optional fixer: set_literal
RefactoringTool: Skipping optional fixer: ws_comma
RefactoringTool: No changes to vSPC.py/setup.py
RefactoringTool: No changes to vSPC.py/lib/__init__.py
RefactoringTool: Refactored vSPC.py/lib/admin.py
--- vSPC.py/lib/admin.py        (original)
+++ vSPC.py/lib/admin.py        (refactored)
@@ -29,15 +29,15 @@
 # authors and should not be interpreted as representing official policies, either expressed
 # or implied, of <copyright holder>.
 
-import cPickle as pickle
+import pickle as pickle
 import socket
 import sys
 
 from telnetlib import BINARY, SGA
 
-from telnet import TelnetServer
-from poll import Poller
-from util import prepare_terminal, restore_terminal
+from .telnet import TelnetServer
+from .poll import Poller
+from .util import prepare_terminal, restore_terminal
 
 # Query protocol
 Q_VERS        = 2
@@ -222,7 +222,7 @@
             out = "%s:%s" % (vm[Q_NAME], vm[Q_UUID])
             if vm[Q_PORT] is not None:
                 out += ":%d" % vm[Q_PORT]
-            print out
+            print(out)
 
     def prepare_terminal(self):
         (oldterm, oldflags) = prepare_terminal(self.command_source)
@@ -250,7 +250,7 @@
             self.add_reader(self.vspc_socket, self.new_server_data)
             self.add_reader(self.command_source, self.new_client_data)
             self.run_forever()
-        except Exception, e:
+        except Exception as e:
             sys.stderr.write("Caught exception %s, closing" % e)
         finally:
             self.quit()
RefactoringTool: Refactored vSPC.py/lib/backend.py
--- vSPC.py/lib/backend.py      (original)
+++ vSPC.py/lib/backend.py      (refactored)
@@ -33,15 +33,15 @@
 import logging
 import optparse
 import os
-import cPickle as pickle
+import pickle as pickle
 import signal
 import socket
 import string
 import sys
 import threading
-import Queue
-
-from admin import Q_VERS, Q_NAME, Q_UUID, Q_PORT, Q_OK, Q_VM_NOTFOUND, Q_LOCK_EXCL, Q_LOCK_WRITE, Q_LOCK_FFA, Q_LOCK_FFAR, Q_LOCK_BAD, Q_LOCK_FAILED
+import queue
+
+from .admin import Q_VERS, Q_NAME, Q_UUID, Q_PORT, Q_OK, Q_VM_NOTFOUND, Q_LOCK_EXCL, Q_LOCK_WRITE, Q_LOCK_FFA, Q_LOCK_FFAR, Q_LOCK_BAD, Q_LOCK_FAILED
 
 class vSPCBackendMemory:
     ADMIN_THREADS = 4
@@ -61,15 +61,15 @@
             self.lock = threading.Lock()
 
     def __init__(self):
-        self.admin_queue = Queue.Queue()
+        self.admin_queue = queue.Queue()
         self.admin_threads = []
 
-        self.observer_queue = Queue.Queue()
+        self.observer_queue = queue.Queue()
         self.observed_vms_lock = threading.Lock()
         self.observed_vms = {}
         self.observed_vms_loaded = False
 
-        self.hook_queue = Queue.Queue()
+        self.hook_queue = queue.Queue()
 
     def get_option_group(self, parser):
         group = optparse.OptionGroup(parser, "Memory backend options",
@@ -100,7 +100,7 @@
         while True:
             try:
                 queue.get()()
-            except Exception, e:
+            except Exception as e:
                 logging.exception("Worker exception caught")
 
     def admin_run(self):
@@ -134,7 +134,7 @@
         with self.observed_vms_lock:
             vms = self.observed_vms.copy()
 
-        return vms.values()
+        return list(vms.values())
 
     def notify_vm(self, uuid, name, port):
         self.observer_queue.put(lambda: self.vm(uuid, name, port))
@@ -184,7 +184,7 @@
 
     def vm_del(self, uuid):
         with self.observed_vms_lock:
-            if self.observed_vms.has_key(uuid):
+            if uuid in self.observed_vms:
                 del self.observed_vms[uuid]
 
         self.hook_queue.put(lambda: self.vm_del_hook(uuid))
@@ -252,7 +252,7 @@
             else:
                 pickle.dump(Exception('No common version'), sockfile)
             sockfile.flush()
-        except Exception, e:
+        except Exception as e:
             logging.debug('handle_query_socket exception: %s', str(e))
 
     def format_vm_listing(self):
@@ -384,7 +384,7 @@
 
     def load_vms(self):
         vms = {}
-        for v in self.shelf.values():
+        for v in list(self.shelf.values()):
             vms[v[P_UUID]] = \
                 self.OVm(uuid = v[P_UUID], name = v[P_NAME], port = v[P_PORT])
 
@@ -422,7 +422,7 @@
         self.scrollback_limit = options.context
 
     def shutdown(self):
-        for k, f in self.logfiles.iteritems():
+        for k, f in self.logfiles.items():
             f.close()
 
     def add_scrollback(self, uuid, msg):
@@ -442,7 +442,7 @@
             f.write(msg)
             f.flush()
             self.add_scrollback(uuid, msg)
-        except ValueError, e:
+        except ValueError as e:
             # we tried to write to a closed fd, which means that we were
             # told to reload our log files between when we got the file
             # descriptor and when we tried to write to it. if we try
@@ -479,7 +479,7 @@
         return self.logfiles[uuid]
 
     def reload(self):
-        for k, f in self.logfiles.iteritems():
+        for k, f in self.logfiles.items():
             f.close()
             del(self.logfiles[k])
             self.logfiles[k] = self.file_for_vm(self.vm_names[k], k)
RefactoringTool: Refactored vSPC.py/lib/poll.py
--- vSPC.py/lib/poll.py (original)
+++ vSPC.py/lib/poll.py (refactored)
@@ -179,7 +179,7 @@
         with self.lock:
             try:
                 self.unsafe_remove_fd(stream)
-            except IOError, e:
+            except IOError as e:
                 if e.errno != errno.EBADF:
                     raise
 
@@ -198,7 +198,7 @@
         """
         try:
             events = self.epoll.poll(timeout)
-        except IOError, e:
+        except IOError as e:
             if e.errno == errno.EINTR:
                 # interrupted syscall; continue w/o error
                 return False
@@ -271,8 +271,8 @@
     def run_once(self, timeout = None):
         try:
             (readers, writers, exceptions) = \
-                select.select(self.read_handlers.keys(), [], [], timeout)
-        except select.error, e:
+                select.select(list(self.read_handlers.keys()), [], [], timeout)
+        except select.error as e:
             # interrupted syscall
             return False
         for reader in readers:
RefactoringTool: Refactored vSPC.py/lib/server.py
--- vSPC.py/lib/server.py       (original)
+++ vSPC.py/lib/server.py       (refactored)
@@ -27,7 +27,7 @@
 # The views and conclusions contained in the software and documentation are those of the
 # authors and should not be interpreted as representing official policies, either expressed
 # or implied, of <copyright holder>.
-from __future__ import with_statement
+
 
 __author__ = "Zachary M. Loafman"
 __copyright__ = "Copyright (C) 2011 Isilon Systems LLC."
@@ -39,7 +39,7 @@
 import ssl
 import time
 import threading
-import Queue
+import queue
 
 from telnetlib import BINARY, SGA, ECHO
 
@@ -104,7 +104,7 @@
         self.ssl_cert = ssl_cert
         self.ssl_key = ssl_key
 
-        self.task_queue = Queue.Queue()
+        self.task_queue = queue.Queue()
         self.task_queue_threads = []
 
         # raise the open files soft limit up to the hard limit to maximize
@@ -128,7 +128,7 @@
         while True:
             try:
                 queue.get()()
-            except Exception, e:
+            except Exception as e:
                 logging.exception("Worker exception caught")
 
     def task_queue_run(self):
@@ -157,7 +157,7 @@
 
         vm_connections = len(self.vms)
         client_connections = 0
-        for uuid in self.vms.keys():
+        for uuid in list(self.vms.keys()):
             try:
                 vm = self.vms[uuid]
                 client_connections += len(vm.clients)
@@ -192,7 +192,7 @@
         try:
             vt = VMTelnetServer(sock, handler = self)
             self.add_reader(vt, self.queue_new_vm_data)
-        except socket.error, err:
+        except socket.error as err:
             # If there was a socket error on initialization, capture the
             # exception to avoid logging a traceback.
             logging.debug("uninitialized VM socket error")
@@ -218,7 +218,7 @@
         try:
             client = self.Client(sock)
             client.uuid = vm.uuid
-        except socket.error, err:
+        except socket.error as err:
             # If there was a socket error on initialization, capture the
             # exception to avoid logging a traceback.
             logging.debug("uninitialized client socket error")
@@ -282,7 +282,7 @@
             self.add_reader(vt, self.queue_new_vm_data)
             return
 
-        if not vt.uuid or not self.vms.has_key(vt.uuid):
+        if not vt.uuid or vt.uuid not in self.vms:
             # In limbo, no one can hear you scream
             self.add_reader(vt, self.queue_new_vm_data)
             return
@@ -294,7 +294,7 @@
         for cl in clients:
             try:
                 self.send_buffered(cl, s)
-            except (EOFError, IOError, socket.error), e:
+            except (EOFError, IOError, socket.error) as e:
                 logging.debug('cl.socket send error: %s', str(e))
                 self.abort_client_connection(cl)
         self.add_reader(vt, self.queue_new_vm_data)
@@ -347,7 +347,7 @@
         for vt in self.vms[client.uuid].vts:
             try:
                 self.send_buffered(vt, s)
-            except (EOFError, IOError, socket.error), e:
+            except (EOFError, IOError, socket.error) as e:
                 logging.debug('cl.socket send error: %s', str(e))
         self.add_reader(client, self.queue_new_client_data)
 
@@ -381,7 +381,7 @@
         self.new_vm(vt.uuid, vt.name, vts = [vt])
 
     def handle_vc_uuid(self, vt):
-        if not self.vms.has_key(vt.uuid):
+        if vt.uuid not in self.vms:
             self._add_vm_when_ready(vt)
             return
 
@@ -395,7 +395,7 @@
         logging.info('VM %s (uuid %s) reconnected/vmotion', vm.name, vm.uuid)
 
     def handle_vm_name(self, vt):
-        if not self.vms.has_key(vt.uuid):
+        if vt.uuid not in self.vms:
             self._add_vm_when_ready(vt)
             return
 
@@ -419,7 +419,7 @@
         return True
 
     def handle_vmotion_peer(self, vt, data):
-        if not self.vmotions.has_key(data):
+        if data not in self.vmotions:
             logging.debug('peer cookie %s doesn\'t exist', hexdump(data))
             return False
 
@@ -498,7 +498,7 @@
 
         orphans = self.orphans[:]
         for uuid in orphans:
-            if not self.vms.has_key(uuid):
+            if uuid not in self.vms:
                 self.orphans.remove(uuid)
                 continue
             vm = self.vms[uuid]
@@ -524,7 +524,7 @@
             orphans = self.orphans[:]
             orphans.sort(key=lambda uuid: self.vms[uuid].last_time,
                          reverse=True)
-            for index in xrange(min(connection_overage, len(orphans))):
+            for index in range(min(connection_overage, len(orphans))):
                 uuid = orphans[index]
                 vm = self.vms[uuid]
                 self.expire_orphan(vm)
@@ -559,13 +559,13 @@
             vm.port = port
         else:
             p = self.vm_port_next
-            while self.ports.has_key(p):
+            while p in self.ports:
                 p += 1
 
             self.vm_port_next = p + 1
             vm.port = p
 
-        assert not self.ports.has_key(vm.port)
+        assert vm.port not in self.ports
         self.ports[vm.port] = vm.uuid
 
         vm.listener = openport(vm.port, self.vm_iface)
RefactoringTool: Refactored vSPC.py/lib/telnet.py
--- vSPC.py/lib/telnet.py       (original)
+++ vSPC.py/lib/telnet.py       (refactored)
@@ -37,6 +37,7 @@
 
 from telnetlib import *
 from telnetlib import IAC,DO,DONT,WILL,WONT,BINARY,ECHO,SGA,SB,SE,NOOPT,theNULL
+from functools import reduce
 
 # How long to wait for an option response. Any option response resets
 # the counter. This is mainly to deal with "raw" connections (like
@@ -275,7 +276,7 @@
     def negotiation_done(self):
         self.process_available()
         if self.unacked:
-            desc = map(lambda (x, y): (ord(x), ord(y)), self.unacked)
+            desc = [(ord(x_y[0]), ord(x_y[1])) for x_y in self.unacked]
             if time.time() > self.last_ack + UNACK_TIMEOUT:
                 logging.debug("timeout waiting for commands %s", desc)
                 self.unacked = []
@@ -328,7 +329,7 @@
         self.sock.sendall(IAC + SB + VMWARE_EXT + s + IAC + SE)
 
     def _handle_known_options(self, data):
-        logging.debug("client knows VM commands: %s", map(ord, data))
+        logging.debug("client knows VM commands: %s", list(map(ord, data)))
 
     def _handle_unknown_option(self, data):
         logging.debug("client doesn't know VM command %d, dropping",
@@ -413,7 +414,7 @@
         data = data[2:]
 
         handled = False
-        if EXT_SUPPORTED.has_key(subcmd):
+        if subcmd in EXT_SUPPORTED:
             meth = '_handle_%s' % EXT_SUPPORTED[subcmd]
             if hasattr(self, meth):
                 getattr(self, meth)(data)
@@ -439,7 +440,7 @@
         self.sock.sendall(IAC + SB + VMWARE_EXT + s + IAC + SE)
 
     def _handle_known_options(self, data):
-        logging.debug("client knows VM commands: %s", map(ord, data))
+        logging.debug("client knows VM commands: %s", list(map(ord, data)))
 
     def _handle_unknown_option(self, data):
         logging.debug("client doesn't know VM command %d, dropping", hexdump(data))
@@ -498,7 +499,7 @@
         data = data[2:]
 
         handled = False
-        if EXT_SUPPORTED.has_key(subcmd):
+        if subcmd in EXT_SUPPORTED:
             meth = '_handle_%s' % EXT_SUPPORTED[subcmd]
             if hasattr(self, meth):
                 getattr(self, meth)(data)
RefactoringTool: Refactored vSPC.py/lib/test.py
--- vSPC.py/lib/test.py (original)
+++ vSPC.py/lib/test.py (refactored)
@@ -7,9 +7,9 @@
 import sys
 import termios
 
-from poll import Poller
-from telnet import VMTelnetProxyClient
-from util import prepare_terminal_with_flags, restore_terminal, string_dump, build_flags_ssh
+from .poll import Poller
+from .telnet import VMTelnetProxyClient
+from .util import prepare_terminal_with_flags, restore_terminal, string_dump, build_flags_ssh
 
 CLIENT_ESCAPE_CHAR = chr(29)
 
RefactoringTool: Refactored vSPC.py/lib/util.py
--- vSPC.py/lib/util.py (original)
+++ vSPC.py/lib/util.py (refactored)
@@ -52,4 +52,4 @@
     """
     Translate a string into ASCII character codes & split with spaces.
     """
-    return " ".join(map(lambda x: str(ord(x)), list(s)))
+    return " ".join([str(ord(x)) for x in list(s)])
RefactoringTool: No changes to vSPC.py/sample/vSPCBackendSample.py
RefactoringTool: No changes to vSPC.py/util/dummy-client.py
RefactoringTool: Files that were modified:
RefactoringTool: vSPC.py/setup.py
RefactoringTool: vSPC.py/lib/__init__.py
RefactoringTool: vSPC.py/lib/admin.py
RefactoringTool: vSPC.py/lib/backend.py
RefactoringTool: vSPC.py/lib/poll.py
RefactoringTool: vSPC.py/lib/server.py
RefactoringTool: vSPC.py/lib/telnet.py
RefactoringTool: vSPC.py/lib/test.py
RefactoringTool: vSPC.py/lib/util.py
RefactoringTool: vSPC.py/sample/vSPCBackendSample.py
RefactoringTool: vSPC.py/util/dummy-client.py


$ 2to3 vSPC.py/vSPCServer -w -n
RefactoringTool: Skipping optional fixer: buffer
RefactoringTool: Skipping optional fixer: idioms
RefactoringTool: Skipping optional fixer: set_literal
RefactoringTool: Skipping optional fixer: ws_comma
RefactoringTool: Refactored vSPC.py/vSPCServer
--- vSPC.py/vSPCServer  (original)
+++ vSPC.py/vSPCServer  (refactored)
@@ -83,7 +83,7 @@
 
 def get_backend_type(shortname):
     name = "vSPCBackend" + shortname
-    if globals().has_key(name):
+    if name in globals():
         backend_type = globals()[name]
     else:
         # Try importing assuming that PYTHONPATH has been set.
@@ -97,16 +97,16 @@
                 __import__(module_name)
                 module = sys.modules[module_name]
             except ImportError:
-                print "No built-in backend type '%s' found. Error trying to " \
+                print("No built-in backend type '%s' found. Error trying to " \
                     "import backend (looking for %s.py). Either the module " \
                     "wasn't on your PYTHONPATH or, if it was, there was an " \
-                    "error in the backend file." % (shortname, name)
+                    "error in the backend file." % (shortname, name))
                 sys.exit(1)
 
         try:
             backend_type = getattr(module, name)
         except AttributeError:
-            print "Backend module %s loaded, but class %s not found" % (name, name)
+            print("Backend module %s loaded, but class %s not found" % (name, name))
             sys.exit(1)
 
     return backend_type
@@ -189,7 +189,7 @@
 
     try:
         backend.setup(options)
-    except ValueError, err:
+    except ValueError as err:
         parser.error(err)
         sys.exit(2)
 
@@ -213,7 +213,7 @@
         logging.info("Shutdown requested on keyboard, exiting")
         backend.shutdown()
         return 0
-    except Exception, e:
+    except Exception as e:
         logging.exception("Top level exception caught")
         backend.shutdown()
         return 1
RefactoringTool: Files that were modified:
RefactoringTool: vSPC.py/vSPCServer

$ 2to3 vSPC.py/vSPCClient -w -n
RefactoringTool: Skipping optional fixer: buffer
RefactoringTool: Skipping optional fixer: idioms
RefactoringTool: Skipping optional fixer: set_literal
RefactoringTool: Skipping optional fixer: ws_comma
RefactoringTool: No changes to vSPC.py/vSPCClient
RefactoringTool: Files that need to be modified:
RefactoringTool: vSPC.py/vSPCClient
